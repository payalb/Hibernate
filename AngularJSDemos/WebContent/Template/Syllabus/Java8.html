<br><br>
<h2 >Java 8 New Features</h2>
<ul>

<h4><li><u>Introducing Lambda Expressions</u></li></h4>

    Describing the purpose of an anonymous inner class
    Describing drawbacks to anonymous inner classes
    Describing the components of a lambda expression
    Defining a functional interface
    Creating programs that use lambda expressions

<h4><li><u>A Case for Lambda Expressions</u></li></h4>

    Discussing the reasons for adding lambda expressions to the Java language
    Reviewing the standard way of extracting data in Java
    Refactoring code to reduce redundancy
    Refactoring code to use inner classes
    Refactoring code to use lambda expressions
    Listing the benefits of lambda expressions

<h4><li><u>Filtering Collections with Lambdas</u></li></h4>

    Iterating though a collection with forEach
    Iterating through a collection using lambda syntax
    Describing the Stream interface
    Filtering a collection using lambda expressions
    Calling an existing method using a method reference
    Chaining multiple methods together
    Comparing function and imperative programming
    Defining pipelines in terms of lambdas and collections

<h4><li><u>Using Built in Lambda Types</u></li></h4>

    Listing the built in interfaces included in java.util.function
    Determining true or false with a Predicate
    Processing an object and return nothing with Consumer
    Processing one object and return another with Function
    Generating a new object with Supplier
    Using primitive versions of the base interfaces
    Using binary versions of the base interfaces

<h4><li><u>Collection Operations with Lambda</u></li></h4>

    Extracting data from an object using map
    Searching for data using search methods
    Describing the types of stream operations
    Describing the Optional class
    Performing calculations using methods
    Describing lazy processing
    Sorting a stream
    Saving results to a collection using the collect method

<h4><li><u>Parallel Streams</u></li></h4>

    Reviewing the key characteristics of streams
    Contrasting old style loop operations with streams
    Describing how to make a stream pipeline execute in parallel
    Listing the key assumptions needed to use a parallel pipeline
    Defining reduction
    Describing why reduction requires an associative function
    Calculating a value using reduce
    Describing the process for decomposing and then merging work

<h4><li><u>Lambda Cookbook</u></li></h4>

    Modifying a list using removeIf
    Updating a list using replaceAll
    Updating a map using computeIfAbsent, computerIfPresent, and merge
    Sending the keys and values from a map to a stream
    Reading a file to a stream
    Reading a text file into an ArrayList
    List, walk, and search a directory structure using a stream
    Flattening a stream using flatMap

<h4><li><u>Method Enhancements</u></li></h4>

    Considering the importance of building good libraries
    Using static methods in Interfaces
    Using default methods
    Understanding default method inheritance rules

<h4><li><u>Using the Date/Time API: Working with Local Dates and Times</u></li></h4>

    Listing the goals of the Date/Time API (JSR-310)
    Creating and manage date-based events
    Creating and manage time-based events
    Combining date and time into a single object

<h4><li><u>Using the Date/Time API: Working with Time Zones</u></li></h4>

    Working with dates and times across time-zones and manage changes resulting from daylight savings

<h4><li><u>Using the Date/Time API: Working with Date and Time Amounts</u></li></h4>

    Defining and create timestamps, periods and durations
    Applying formatting to local and zoned dates and times

<h4><li><u>JavaScript on Java with Nashorn: Creating and executing shell scripts</u></li></h4>

    Creating and execute shell scripts using JavaScript and Nashorn

<h4><li><u>JavaScript on Java with Nashorn: Writing JavaScript Applications</u></li></h4>

    Developing JavaScript applications that leverage Java code using Nashorn

<h4><li><u>JavaScript on Java with Nashorn: Writing JavaFX Applications Using JavaScript</u></li></h4>

    Running JavaScript script from Java applications usingJSR-223
    Prototype JavaFX applications using Nashorn and JavaScript

<h4><li><u>Intro to Mission Control</u></li></h4>

    Describing JMX and Managed Beans with Mission Control
    Monitoring CPU utilization with Mission Control
    Analyzing JVM characteristics with Mission Control
    Analyzing heap memory with Mission Control

<h4><li><u>Intro to Flight Recorder</u></li></h4>

    Describing the Java Flight Recorder
    Describing the Java Flight Recorder Architecture
    Starting a Java Flight Recording
    Managing a Java Flight Recording
    Analyzing a Java Flight Recording
    </ul>