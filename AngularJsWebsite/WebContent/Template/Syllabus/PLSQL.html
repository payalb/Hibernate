<br><br><ul>
<h4><u><li>
Oracle Database 11g: PL/SQL Fundamentals</li></u></h4> 

    Introduction to PL/SQL
    Explain the need for PL/SQL
    Explain the benefits of PL/SQL
    Identify the different types of PL/SQL blocks
    Output messages in PL/SQL
    Declaring PL/SQL Variables
    Recognize valid and invalid identifiers
    List the uses of variables, declare and initialize variables, use bind variables
    List and describe various data types using the %TYPE attribute
    Writing Executable Statements
    Identify lexical units in a PL/SQL block
    Use built-in SQL functions in PL/SQL and sequences in PL/SQL expressions
    Describe when implicit conversions take place and when explicit conversions have to be dealt with
    Write nested blocks and qualify variables with labels
    Write readable code with appropriate indentation
    Interacting with the Oracle Database Server
    Create PL/SQL executable blocks using DML and transaction control statements
    Make use of the INTO clause to hold the values returned by a SQL statement
    Writing Control Structures
    Identify the uses and types of control structures (IF, CASE statements and expressions)
    Construct and identify loop statements
    Apply guidelines when using conditional control structures
    Working with Composite Data Types
    Create user-defined PL/SQL records
    Create a record with the %ROWTYPE attribute
    Create an INDEX BY table and INDEX BY table of records
    Describe the differences among records, tables, and tables of records
    Using Explicit Cursors
    Distinguish between usage of implicit and explicit cursors, use SQL cursor attributes
    Declare and control explicit cursors, use simple loops and cursor FOR loops to fetch data
    Declare and use cursors with parameters
    Lock rows with the FOR UPDATE clause and reference the current row with the WHERE CURRENT OF clause
    Handling Exceptions
    Define PL/SQL exceptions
    Recognize unhandled exceptions
    Handle different types of exceptions (pre-defined exceptions, non-predefined exceptions and user-defined exceptions)
    Propagate exceptions in nested blocks and call applications
    Creating Stored Procedures and Functions
    Differentiate between anonymous blocks and subprograms
    Create a simple procedure and invoke it from an anonymous block
    Create a simple function
    Create a simple function that accepts a parameter
    Differentiate between procedures and functions

<h4><u><li>Oracle Database 11g: Develop PL/SQL Program Units</li></u></h4> 

    Creating Procedures
    Differentiate between anonymous blocks and subprograms, use a modularized and layered subprogram design, and identify the benefits of subprograms
    Create a simple procedure and invoke it from an anonymous block
    Work with procedures
    Handle exceptions in procedures, remove a procedure, and display a procedure's information
    Creating Functions
    Differentiate between a procedure and a function
    Describe the uses of functions
    Work with functions (create, invoke and remove functions)
    Creating Packages
    Identify the benefits and the components of packages
    Work with packages (create package specification and body, invoke package subprograms, remove a package and display package information)
    Working with Packages
    Overload package subprograms, use forward declarations
    Create an initialization block in a package body
    Manage persistent package data states for the life of a session and use PL/SQL tables and records in packages
    Using Oracle-Supplied Packages in Application Development
    Describe how the DBMS_OUTPUT package works
    Use UTL_FILE to direct output to operating system files
    Describe the main features of UTL_MAIL
    Using Dynamic SQL
    Describe the execution flow of SQL statements
    Use Native Dynamic SQL (NDS)
    Use the DBMS_SQL package
    Design Considerations for PL/SQL Code
    Create standard constants and exceptions
    Write and call local subprograms
    Control the run-time privileges of a subprogram
    Perform autonomous transactions
    Use NOCOPY hint, PARALLEL ENABLE hint and DETERMINISTIC clause
    Use bulk binding and the RETURNING clause with DML
    Creating Triggers
    Describe different types of triggers and their uses
    Create database triggers
    Manage triggers
    Creating Compound, DDL, and Event Database Triggers
    Create triggers on DDL statements
    Create triggers on system events
    Using the PL/SQL Compiler
    Describe the new PL/SQL compiler and features
    Use the new PL/SQL compiler initialization parameters
    Use the new PL/SQL compile time warnings
    Managing PL/SQL Code
    Describe and use conditional compilation
    Hide PL/SQL source code using dynamic obfuscation and the Wrap utility
    Managing Dependencies
    Track and manage procedural dependencies

 
<h4><u><li>Designing PL/SQL Code</li></u></h4> 

    Identify guidelines for cursor design
    Use cursor variables
    Use DBMS_SQL functions and 12c new security features
    Create subtypes based on existing types
    Specify a white list of PL/SQL units to access a package
    Use PL/SQL bind types

<h4><u><li>Creating and Managing Collections</li></u></h4> 

    Create and manage nested tables
    Create and manage varrays
    Create and manage associative arrays/PLSQL tables

<h4><u><li>Working with Collections</li></u></h4> 

    Manipulate collections
    Distinguish between the different types of collections and their uses
    Use nested collections
    Use collection of objects

<h4><u><li>Manipulating Large Objects</li></u></h4> 

    Create and maintain LOB data types
    Differentiate between internal and external LOBs
    Use the DBMS_LOB PL/SQL package
    Use of temporary LOBs
    Describe and use SecureFile LOB

<h4><u><li>Using Advanced Interface Methods</li></u></h4> 

    Execute external C programs from PL/SQL
    Execute Java programs from PL/SQL

<h4><u><li>Tuning PL/SQL Performance</li></u></h4> 

    Use native and interpreted compilation methods
    Optimize PL/SQL code 
    Enable intraunit inlining
    Use the FETCH FIRST clause
    Use PL/SQL functions that run faster in SQL
    Use DBMS_PARALLEL_EXECUTE package

<h4><u><li>Improving Performance with Caching</li></u></h4> 

    Identify when to result cache a function
    Handle session dependencies in a result cache function
    Set up PL/SQL functions to use PL/SQL result caching
    Invoker’s Right function result caching 
    Explain invalidation of  cache results
    Use the DBMS_RESULT_CACHE package

<h4><u><li>Analyzing PL/SQL Code</li></u></h4> 

    Use the supplied packages and dictionary views to find coding information
    Determine identifier types and usages with PL/Scope
    Use the DBMS_METADATA package for creation DDL that can be used to re-create the objects
    Use the UTL_CALL_STACK Package
    Use compile time warnings
    Use conditional compilation

<h4><u><li>Profiling and Tracing PL/SQL Code</li></u></h4> 

    Trace PL/SQL program execution
    Profile PL/SQL applications

<h4><u><li>Implementing Fine-Grained Access Control for VPD</li></u></h4> 

    Explain the process of fine-grained access control
    Build security policies 

<h4><u><li>Safeguarding Your Code Against SQL Injection Attacks</li></u></h4> 

    Explain SQL injection
    Reduce attack surfaces
    Use DBMS_ASSERT

<h4><u><li>Miscellaneous</li></u></h4> 

    Grant roles to PL/SQL packages and standalone programs
    "Use BEQUEATH CURRENT_USER views
    Enable INHERIT PRIVILEGES and INHERIT ANY PRIVILEGES privileges
    Use invisible columns with  %ROWTYPE attribute 
    Use Edition-Based Redefinition

<h4><u><li>Multidisciplinary</li></u></h4> 

    Items wherein concepts across multiple objectives will be tested in each item

 </ul>
 